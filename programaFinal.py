# -*- coding: utf-8 -*-
"""Pre-Processing GOES-R Series Data (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12E_F5xmqD9Ep5ajj-aHHAv7t48srr9Ci
"""

import xarray as xr
import numpy as np
import matplotlib.pyplot as plt
from math import atan, tan, radians, cos, sin, asin, sqrt
import glob
import os
import xarray as xr
import pickle

# Función para cargar datos
def load_data():
    with open('data_dict.pickle', 'rb') as handle:
        return pickle.load(handle)

# Intenta cargar el diccionario al inicio del script
try:
    data_dict = load_data()
except (FileNotFoundError, EOFError):
    data_dict = {}  # Si no existe, comienza con un diccionario vacío



def lat_lon_to_xy(lat, lon, goes_height, goes_longitude)->tuple:
    """
    Convert latitude and longitude to x and y coordinates in the GOES projection.

    Parameters:
    - lat: Latitude in degrees.
    - lon: Longitude in degrees.
    - goes_height: Height of the GOES satellite above the Earth's surface in meters.
    - goes_longitude: Longitude of the GOES satellite.

    Returns:
    - x, y coordinates in the GOES projection.
    """
    # Earth's radii for spherical Earth model
    e_radius = 6378.137  # equatorial radius in km
    p_radius = 6356.7523  # polar radius in km

    # Convert lat/lon to radians
    lat_rad = radians(lat)
    lon_rad = radians(lon)
    lon_diff_rad = radians(lon - goes_longitude)

    # Convert geodetic lat to geocentric lat to correct for Earth's flattening
    geocentric_lat = atan((p_radius / e_radius)**2 * tan(lat_rad))

    # Calculate distance from Earth center to the surface at the given lat/lon
    r_c = p_radius / sqrt(1 - e_radius**2 * cos(geocentric_lat)**2 / e_radius**2)

    # Satellite height converted from meters to kilometers
    r_sat = e_radius + goes_height / 1000.0

    # Calculate satellite-relative x, y, z coordinates
    s_x = r_c * cos(geocentric_lat) * sin(lon_diff_rad)
    s_y = -r_c * sin(geocentric_lat)
    s_z = r_c * cos(geocentric_lat) * cos(lon_diff_rad)

    # Convert to x, y in the satellite's projection
    x = atan(s_x / (r_sat - s_z))
    y = asin(s_y / sqrt(s_x**2 + (r_sat - s_z)**2 + s_y**2))

    return x, y


# Preprocesado de de dataset para producto DSR
def preprocess_dataset(dataset_path, dataset_var, target_center, crop_size)->np.ndarray:
    dataset = xr.open_dataset(dataset_path, decode_times=False, engine='h5netcdf')

    # Extract the DSR values and geographic coordinates
    ds_values = dataset[dataset_var].values
    all_longitudes = dataset['lon'].values
    all_latitudes = dataset['lat'].values
    lon_spacing = np.mean(np.diff(all_longitudes))
    lat_spacing = np.mean(np.diff(all_latitudes))

    # Identify the closest indices to the target center coordinates
    target_lon_index = np.argmin(np.abs(all_longitudes - target_center[1]))
    target_lat_index = np.argmin(np.abs(all_latitudes - target_center[0]))

    # Calculate the pixel span for the desired crop size
    pixel_span_lon = int(crop_size[1] / abs(lon_spacing))
    pixel_span_lat = int(crop_size[0] / abs(lat_spacing))

    # Define the bounds for cropping
    start_lon = max(target_lon_index - pixel_span_lon // 2, 0)
    end_lon = min(target_lon_index + pixel_span_lon // 2, len(all_longitudes) - 1)
    start_lat = max(target_lat_index - pixel_span_lat // 2, 0)
    end_lat = min(target_lat_index + pixel_span_lat // 2, len(all_latitudes) - 1)

    # Execute the crop
    cropped_image = ds_values[start_lat:end_lat, start_lon:end_lon]

    return cropped_image

#%%
center_lat_lon = (25.6866, -100.3161)  # Monterrey's geographical coordinates
crop_size_lat_lon = (8, 8)  # Degrees of latitude and longitude for cropping
#%%


def rotate_coordinates(x, y, angle_degrees):
    """
    Rotate coordinates (x, y) around the origin (0, 0) by a given angle in degrees.

    Parameters:
    - x, y: Original coordinates to be rotated.
    - angle_degrees: The angle of rotation in degrees. Counter-clockwise is positive.

    Returns:
    - Rotated coordinates x_rotated, y_rotated.
    """
    angle_radians = np.radians(angle_degrees)
    x_rotated = x * np.cos(angle_radians) - y * np.sin(angle_radians)
    y_rotated = x * np.sin(angle_radians) + y * np.cos(angle_radians)
    return x_rotated, y_rotated

#Retorna las coordenadas rotadas en el eje x y y para valores COD
def center_crop_rotate_data(ds,variable_name,dataset_path, center_lat_lon, crop_size_lat_lon, orientation='north')->np.ndarray: 
    """
    Crop and rotate Cloud Optical Depth (COD) data centered on a specific lat/lon.

    Parameters:
    - dataset_path: Path to the GOES dataset file.
    - center_lat_lon: Tuple of (latitude, longitude) for the center of the crop.
    - crop_size_lat_lon: Tuple of (latitude span, longitude span) for the crop size.
    - orientation: String indicating the final upward direction ('north', 'east', 'south', 'west').

    Returns:
    - Cropped and rotated COD data as a 2D numpy array.
    """
    # Load dataset
    ds = xr.open_dataset(dataset_path)
    print(ds)
    goes_imager_projection_attrs = ds['goes_imager_projection'].attrs
    goes_height = goes_imager_projection_attrs['perspective_point_height']
    goes_longitude = goes_imager_projection_attrs['longitude_of_projection_origin']

    # Extract Cloud Optical Depth (COD) values
    cod = ds['COD'].values
    variable_data = ds[variable_name].values
    print(cod)

    # Convert center lat/lon to x, y coordinates in GOES projection
    center_x, center_y = lat_lon_to_xy(center_lat_lon[0], center_lat_lon[1], goes_height, goes_longitude)

    # Map desired orientation to rotation angle
    rotation_angles = {'north': 0, 'east': 90, 'south': 180, 'west': 270}
    rotation_angle = rotation_angles.get(orientation.lower(), 0)

    # Convert x, y to pixel positions
    x_factor = cod.shape[1] / (2 * np.pi)
    y_factor = cod.shape[0] / (np.pi)
    center_x_px = (center_x + np.pi) * x_factor
    center_y_px = (np.pi/2 - center_y) * y_factor

    # Determine crop size in pixels
    crop_width_px = crop_size_lat_lon[1] / 360 * cod.shape[1]
    crop_height_px = crop_size_lat_lon[0] / 180 * cod.shape[0]

    # Crop the image around the center point
    left = int(center_x_px - crop_width_px / 2)
    right = int(center_x_px + crop_width_px / 2)
    top = int(center_y_px - crop_height_px / 2)
    bottom = int(center_y_px + crop_height_px / 2)
    cropped_cod = cod[top:bottom, left:right]

    # Rotate the cropped image if needed
    if rotation_angle != 0:
        cropped_cod = np.rot90(cropped_cod, rotation_angle // 90)

    return cropped_cod
def file_reading(dataset_path):
    center_lat_lon = (25.6866, -100.3161)  # Monterrey's geographical coordinates
    crop_size_lat_lon = (4, 4)  # Degrees of latitude and longitude for cropping
    nc_files = glob.glob(os.path.join(dataset_path, '*.nc'))
    variables = ['COD', 'DSR', 'TPW']
    orientation = 'north'  # Orientation for the final image
    # Itera sobre cada archivo en la carpeta
    data_dict = {var: {} for var in variables}
    for file_path in nc_files:
        ds = xr.open_dataset(file_path,decode_times=False)
        time_coverage_start = ds.attrs['time_coverage_start']

        # Procesa y almacena los datos para cada variable
        for var in variables:
            if var in ds.data_vars:
                if var == 'COD':
                    processed_data = center_crop_rotate_data(
                        file_path, var, center_lat_lon, crop_size_lat_lon, orientation
                    )
                    data_dict[var][time_coverage_start] = processed_data
                if var == 'DSR':
                    processed_data = preprocess_dataset(
                        file_path, var, center_lat_lon, crop_size_lat_lon
                    )
                    data_dict[var][time_coverage_start] = processed_data

        ds.close()
    print("diccionario de datos de archivo: ", data_dict)
def save_data(data_dict):
    with open('data_dict.pickle', 'wb') as handle:
        pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)

# Llamas a esta función con tu diccionario de datos como argumento

def codvalues_plotting():
    center_lat_lon = (25.6866, -100.3161)  # Monterrey's geographical coordinates
    crop_size_lat_lon = (4, 4)  # Degrees of latitude and longitude for cropping
    dataset_path = r"F:/dataSetsperProduct4"
    variables = ['COD', 'DSR', 'TPW']
    orientation = 'north'  # Orientation for the final image

    # Original image
    ds = xr.open_dataset(dataset_path)

    # Assuming 'COD' is the correct variable name; adjust if necessary
    cod = ds['COD'].values    
    print(cod.values)


    # Plotting the original Cloud Optical Depth (COD) data
    plt.figure(figsize=(10, 8))
    plt.imshow(cod, cmap='viridis', origin='upper')
    plt.colorbar(label='Cloud Optical Depth')
    plt.title('Original Cloud Optical Depth (COD) Image')
    plt.show()

    # Process the data
    processed = center_crop_rotate_data(dataset_path, center_lat_lon, crop_size_lat_lon, orientation)
    processed

    # Plotting Processed data
    fig, ax = plt.subplots(figsize=(10, 8))
    im = ax.imshow(processed, cmap='viridis', origin='upper')
    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label('Cloud Optical Depth')
    plt.title('Cloud Optical Depth (COD) centered on Monterrey - NORTH up')
    plt.show()

if __name__ == '__main__':
    dataset_path = r"F:/dataSetsperProduct4"
    file_reading(dataset_path)
    
    codvalues_plotting()
    save_data(data_dict)
    




